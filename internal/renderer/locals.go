package renderer

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"

	"github.com/larsenclose/oci-tf-bootstrap/internal/discovery"
)

// nameTracker helps deduplicate TF names by appending suffixes when collisions occur
type nameTracker struct {
	seen map[string]int
}

func newNameTracker() *nameTracker {
	return &nameTracker{seen: make(map[string]int)}
}

// unique returns a unique TF name, appending _2, _3, etc. if the name was already seen
func (t *nameTracker) unique(base string) string {
	name := toTFName(base)
	t.seen[name]++
	if t.seen[name] > 1 {
		return fmt.Sprintf("%s_%d", name, t.seen[name])
	}
	return name
}

// compartmentNode represents a node in the compartment hierarchy
type compartmentNode struct {
	comp     discovery.Compartment
	children []*compartmentNode
}

// buildCompartmentTree builds a tree structure from flat compartment list
func buildCompartmentTree(compartments []discovery.Compartment, tenancyID string) []*compartmentNode {
	nodeMap := make(map[string]*compartmentNode)
	var roots []*compartmentNode

	// Create nodes for all compartments
	for _, c := range compartments {
		nodeMap[c.ID] = &compartmentNode{comp: c}
	}

	// Build tree by linking children to parents
	for _, c := range compartments {
		node := nodeMap[c.ID]
		if c.ParentID == tenancyID || c.ParentID == "" {
			roots = append(roots, node)
		} else if parent, ok := nodeMap[c.ParentID]; ok {
			parent.children = append(parent.children, node)
		} else {
			// Parent not found, treat as root
			roots = append(roots, node)
		}
	}

	// Sort roots and children by name
	sortNodes(roots)
	return roots
}

func sortNodes(nodes []*compartmentNode) {
	sort.Slice(nodes, func(i, j int) bool {
		return nodes[i].comp.Name < nodes[j].comp.Name
	})
	for _, n := range nodes {
		sortNodes(n.children)
	}
}

// writeCompartmentTree writes compartments as a tree with indentation
func writeCompartmentTree(f *os.File, nodes []*compartmentNode, tracker *nameTracker, indent string) {
	for _, node := range nodes {
		name := tracker.unique(node.comp.Name)
		fmt.Fprintf(f, "  comp_%s = %q  # %s%s\n", name, node.comp.ID, indent, node.comp.Name)
		writeCompartmentTree(f, node.children, tracker, indent+"  ")
	}
}

func writeLocals(result *discovery.Result, outputDir string, opts Options) error {
	f, err := os.Create(filepath.Join(outputDir, "locals.tf"))
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "# Generated by oci-tf-bootstrap")
	if opts.AlwaysFree {
		fmt.Fprintln(f, "# Mode: always-free tier resources only")
		fmt.Fprintln(f, "#")
		fmt.Fprintln(f, "# OCI Always-Free Tier Limits:")
		fmt.Fprintln(f, "#   VM.Standard.A1.Flex (ARM): 4 OCPUs + 24GB memory total across ALL A1 instances")
		fmt.Fprintln(f, "#   VM.Standard.E2.1.Micro (x86): 2 instances total (1/8 OCPU, 1GB each)")
		fmt.Fprintln(f, "#   Block Storage: 200GB total (boot + block volumes combined)")
		fmt.Fprintln(f, "#   Object Storage: 20GB (after trial expires)")
		fmt.Fprintln(f, "#   Outbound Data: 10TB/month")
		fmt.Fprintln(f, "#")
		fmt.Fprintln(f, "# Free Networking Resources:")
		fmt.Fprintln(f, "#   - 2 VCNs with internet/NAT/service gateways")
		fmt.Fprintln(f, "#   - 1 Flexible Load Balancer (10 Mbps)")
		fmt.Fprintln(f, "#   - 1 Network Load Balancer")
		fmt.Fprintln(f, "#   - Bastion service (free for all accounts)")
		fmt.Fprintln(f, "#   - Site-to-Site VPN (up to 50 IPSec connections)")
		fmt.Fprintln(f, "#")
		fmt.Fprintln(f, "# WARNING: Idle instances (<20% CPU for 7 days) may be reclaimed by Oracle")
		fmt.Fprintln(f, "# WARNING: Always-free resources must be in home region (except A1.Flex)")
	} else {
		fmt.Fprintln(f, "# Discovered OCIDs and mappings for immediate use")
	}
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "locals {")

	fmt.Fprintln(f, "  # Tenancy")
	fmt.Fprintf(f, "  tenancy_ocid = %q\n", result.Tenancy.ID)
	fmt.Fprintln(f, "")

	fmt.Fprintln(f, "  # Compartments (hierarchical)")
	compTracker := newNameTracker()
	tree := buildCompartmentTree(result.Compartments, result.Tenancy.ID)
	writeCompartmentTree(f, tree, compTracker, "")
	fmt.Fprintln(f, "")

	fmt.Fprintln(f, "  # Availability Domains (tenancy-specific names)")
	for i, ad := range result.AvailabilityDomains {
		fmt.Fprintf(f, "  ad_%d = %q\n", i+1, ad.Name)
	}
	fmt.Fprintln(f, "")

	fmt.Fprintln(f, "  # Validated Shapes (available in tenancy)")
	for _, s := range result.Shapes {
		name := toTFName(s.Name)
		if s.IsFlexible {
			maxOCPU := s.MaxOCPUs
			if maxOCPU == 0 {
				maxOCPU = s.OCPUs // fallback if max not available
			}
			fmt.Fprintf(f, "  shape_%s = %q  # Flex: 1-%.0f OCPU\n", name, s.Name, maxOCPU)
		} else {
			fmt.Fprintf(f, "  shape_%s = %q  # %.0f OCPU, %.0f GB\n", name, s.Name, s.OCPUs, s.MemoryGB)
		}
	}
	fmt.Fprintln(f, "")

	if len(result.VCNs) > 0 {
		fmt.Fprintln(f, "  # Existing VCNs")
		vcnTracker := newNameTracker()
		for _, v := range result.VCNs {
			name := vcnTracker.unique(v.DisplayName)
			fmt.Fprintf(f, "  vcn_%s = %q  # %s\n", name, v.ID, v.CIDRBlock)
		}
		fmt.Fprintln(f, "")

		fmt.Fprintln(f, "  # Existing Subnets")
		subnetTracker := newNameTracker()
		for _, v := range result.VCNs {
			for _, s := range v.Subnets {
				name := subnetTracker.unique(s.DisplayName)
				pubStr := "private"
				if s.IsPublic {
					pubStr = "public"
				}
				fmt.Fprintf(f, "  subnet_%s = %q  # %s, %s\n", name, s.ID, s.CIDRBlock, pubStr)
			}
		}
		fmt.Fprintln(f, "")

		// Security Lists
		var hasSecurityLists bool
		for _, v := range result.VCNs {
			if len(v.SecurityLists) > 0 {
				hasSecurityLists = true
				break
			}
		}
		if hasSecurityLists {
			fmt.Fprintln(f, "  # Existing Security Lists")
			slTracker := newNameTracker()
			for _, v := range result.VCNs {
				for _, sl := range v.SecurityLists {
					name := slTracker.unique(sl.DisplayName)
					ruleCount := len(sl.IngressRules) + len(sl.EgressRules)
					fmt.Fprintf(f, "  seclist_%s = %q  # %d rules\n", name, sl.ID, ruleCount)
				}
			}
			fmt.Fprintln(f, "")
		}

		// Route Tables
		var hasRouteTables bool
		for _, v := range result.VCNs {
			if len(v.RouteTables) > 0 {
				hasRouteTables = true
				break
			}
		}
		if hasRouteTables {
			fmt.Fprintln(f, "  # Existing Route Tables")
			rtTracker := newNameTracker()
			for _, v := range result.VCNs {
				for _, rt := range v.RouteTables {
					name := rtTracker.unique(rt.DisplayName)
					fmt.Fprintf(f, "  routetable_%s = %q  # %d routes\n", name, rt.ID, len(rt.Routes))
				}
			}
			fmt.Fprintln(f, "")
		}

		// Internet Gateways
		var hasIGW bool
		for _, v := range result.VCNs {
			if v.InternetGateway != nil {
				hasIGW = true
				break
			}
		}
		if hasIGW {
			fmt.Fprintln(f, "  # Existing Internet Gateways")
			igwTracker := newNameTracker()
			for _, v := range result.VCNs {
				if v.InternetGateway != nil {
					name := igwTracker.unique(v.InternetGateway.DisplayName)
					status := "enabled"
					if !v.InternetGateway.IsEnabled {
						status = "disabled"
					}
					fmt.Fprintf(f, "  igw_%s = %q  # %s\n", name, v.InternetGateway.ID, status)
				}
			}
			fmt.Fprintln(f, "")
		}

		// NAT Gateways
		var hasNAT bool
		for _, v := range result.VCNs {
			if v.NATGateway != nil {
				hasNAT = true
				break
			}
		}
		if hasNAT {
			fmt.Fprintln(f, "  # Existing NAT Gateways")
			natTracker := newNameTracker()
			for _, v := range result.VCNs {
				if v.NATGateway != nil {
					name := natTracker.unique(v.NATGateway.DisplayName)
					fmt.Fprintf(f, "  nat_%s = %q  # %s\n", name, v.NATGateway.ID, v.NATGateway.PublicIP)
				}
			}
			fmt.Fprintln(f, "")
		}
	}

	// Block Volumes
	if len(result.BlockVolumes) > 0 {
		fmt.Fprintln(f, "  # Existing Block Volumes")
		var totalGB int64
		bvTracker := newNameTracker()
		for _, bv := range result.BlockVolumes {
			name := bvTracker.unique(bv.DisplayName)
			fmt.Fprintf(f, "  blockvol_%s = %q  # %dGB, %s\n", name, bv.ID, bv.SizeGB, bv.AvailabilityDomain)
			totalGB += bv.SizeGB
		}
		fmt.Fprintf(f, "  # Total block storage: %dGB\n", totalGB)
		if opts.AlwaysFree {
			fmt.Fprintln(f, "  # WARNING: Always-free tier limit is 200GB total (boot + block volumes)")
		}
		fmt.Fprintln(f, "")
	}

	fmt.Fprintln(f, "}")
	return nil
}
